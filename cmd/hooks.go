package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/gobeam/stringy"
)

type Hook struct {
	Path    string
	Name    string
	Sourced bool // true if filename ends with .source
}

type HookRunner struct {
	rootDir string
	config  *Config
}

func NewHookRunner(config *Config) *HookRunner {
	return &HookRunner{
		rootDir: config.RootDir(),
		config:  config,
	}
}

// DiscoverHooks finds all hooks in .hooks.d/
func (hr *HookRunner) DiscoverHooks() ([]Hook, error) {
	hooksDir := filepath.Join(hr.rootDir, ".hooks.d")

	// Check if hooks directory exists
	if _, err := os.Stat(hooksDir); os.IsNotExist(err) {
		log.Debugw(".hooks.d directory not found", "path", hooksDir)
		return []Hook{}, nil
	}

	entries, err := os.ReadDir(hooksDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read .hooks.d: %w", err)
	}

	var hooks []Hook
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		name := entry.Name()
		fullPath := filepath.Join(hooksDir, name)

		// Check if this is a sourced hook by file extension
		sourced := strings.HasSuffix(name, ".source")

		// If not a sourced hook, verify it's executable
		if !sourced {
			fileInfo, err := entry.Info()
			if err != nil {
				log.Warnw("failed to stat hook", "path", fullPath, "error", err)
				continue
			}

			if !isExecutableByOwner(fileInfo.Mode()) {
				log.Warnw("skipping non-executable hook without .source suffix", "path", fullPath)
				continue
			}
		}

		hook := Hook{
			Path:    fullPath,
			Name:    name,
			Sourced: sourced,
		}

		hooks = append(hooks, hook)
		log.Debugw("discovered hook", "path", fullPath, "sourced", hook.Sourced)
	}

	// Sort by name lexicographically (00- comes before 10-, etc.)
	sort.Slice(hooks, func(i, j int) bool {
		return hooks[i].Name < hooks[j].Name
	})

	log.Debugw("discovered hooks", "count", len(hooks))
	return hooks, nil
}

// GenerateWrapperScript creates a shell script that sources/executes hooks and execs the target
func (hr *HookRunner) GenerateWrapperScript(hooks []Hook, scriptPath string, scriptArgs []string) (string, error) {
	if len(hooks) == 0 {
		// No hooks, no wrapper needed
		return "", nil
	}

	// Create temp file for wrapper script
	tmpFile, err := os.CreateTemp("", "tome-wrapper-*.sh")
	if err != nil {
		return "", fmt.Errorf("failed to create wrapper script: %w", err)
	}
	defer tmpFile.Close()

	wrapperPath := tmpFile.Name()

	// Build the wrapper script
	script := "#!/usr/bin/env bash\n"
	script += "set -e\n\n" // Exit on error
	script += "# Generated by tome-cli - do not edit\n\n"

	// Export environment variables for hooks
	env := hr.buildHookEnv("", scriptPath, scriptArgs)
	for _, e := range env {
		script += fmt.Sprintf("export %s\n", e)
	}
	script += "\n"

	// Process each hook
	for _, hook := range hooks {
		script += fmt.Sprintf("# Hook: %s\n", hook.Name)

		if hook.Sourced {
			// Source in same shell context
			script += fmt.Sprintf("if ! source %s; then\n", hook.Path)
			script += fmt.Sprintf("  echo 'Error: pre-hook failed: %s (sourcing failed)' >&2\n", hook.Name)
			script += "  exit 1\n"
			script += "fi\n\n"
		} else {
			// Execute as separate process
			script += fmt.Sprintf("if ! %s; then\n", hook.Path)
			script += fmt.Sprintf("  echo 'Error: pre-hook failed: %s' >&2\n", hook.Name)
			script += "  exit 1\n"
			script += "fi\n\n"
		}
	}

	// Finally, exec the target script
	script += "# Execute target script\n"
	argsStr := strings.Join(scriptArgs, " ")
	if argsStr != "" {
		script += fmt.Sprintf("exec %s %s\n", scriptPath, argsStr)
	} else {
		script += fmt.Sprintf("exec %s\n", scriptPath)
	}

	// Write wrapper script
	if _, err := tmpFile.WriteString(script); err != nil {
		os.Remove(wrapperPath)
		return "", fmt.Errorf("failed to write wrapper script: %w", err)
	}

	// Make wrapper executable
	if err := os.Chmod(wrapperPath, 0700); err != nil {
		os.Remove(wrapperPath)
		return "", fmt.Errorf("failed to make wrapper executable: %w", err)
	}

	log.Debugw("generated wrapper script", "path", wrapperPath)
	return wrapperPath, nil
}

func (hr *HookRunner) buildHookEnv(hookPath, scriptPath string, scriptArgs []string) []string {
	var env []string

	// Add tome-cli standard vars
	absRootDir, _ := filepath.Abs(hr.config.RootDir())
	env = append(env, fmt.Sprintf("TOME_ROOT=%s", absRootDir))
	env = append(env, fmt.Sprintf("TOME_EXECUTABLE=%s", hr.config.ExecutableName()))

	// Add uppercase executable-specific vars
	executableAsEnvPrefix := strings.ToUpper(stringy.New(hr.config.ExecutableName()).SnakeCase().Get())
	env = append(env, fmt.Sprintf("%s_ROOT=%s", executableAsEnvPrefix, absRootDir))
	env = append(env, fmt.Sprintf("%s_EXECUTABLE=%s", executableAsEnvPrefix, hr.config.ExecutableName()))

	// Add script-specific vars
	env = append(env, fmt.Sprintf("TOME_SCRIPT_PATH=%s", scriptPath))
	env = append(env, fmt.Sprintf("TOME_SCRIPT_NAME=%s", filepath.Base(scriptPath)))
	env = append(env, fmt.Sprintf(`TOME_SCRIPT_ARGS="%s"`, strings.Join(scriptArgs, " ")))

	return env
}
